---
title: "Aggregating predictions from an SIRS model"
bibliography: bibfile.bib
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Aggregating predictions from an SIRS model}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE, 
  message = FALSE,
  comment = "#>"
)



fig_path <- "/Users/eah394/Documents/GitHub/aggregation_methods/figures/general_sir/"
```

This vignette implements the first case study from [@EAH-ms]. We simulate a multi-model effort to evaluate the performance of various aggregation methods when applied to distributions of public health outcomes. 

To start, we load a few packages.
```{r preamble}
# for agggregation
library(CombineDistributions) 
# for data manipulation
library(dplyr) 
library(data.table)
# for plotting
library(ggplot2)
library(scales)
library(cowplot)
library(tidyr)
# for rmd
library(knitr)

# set seed so we can replicate results
set.seed(20)
```

## SIRS Model
We use an SIRS (susceptible-infected-recovered-susceptible) model implemented stochastically with the chain-binomial framework [@bailey_mathematical_1957]. All individuals in the population are classified into one of the three compartments (S,I, or R), and we define how many individuals transition between these states at each time step: 

| Transition | Number of individuals transitioning |
|------------|------------------------|
| infection  | $\delta_{S \rightarrow I}(t), \text{drawn from}D_{S \rightarrow I}(t) \sim Binomial(S(t), 1 - e^{-\beta I(t)/N})$ |
| recovery   | $\delta_{I \rightarrow R}(t), \text{drawn from}D_{I \rightarrow R}(t) \sim Binomial(S(t), 1 - e^{-\gamma})$ |
| waning     | $\delta_{R \rightarrow S}(t), \text{drawn from}D_{R \rightarrow S}(t) \sim Binomial(S(t), 1 - e^{-\rho})$ |

We update the number of individuals in each compartment accordingly: 

$$
\begin{aligned}
S(t+1) &= S(t) - \delta_{S \rightarrow I}(t) + \delta_{R \rightarrow S}(t) \\
I(t+1) &= I(t) + \delta_{S \rightarrow I}(t) - \delta_{I \rightarrow R}(t)\\
R(t+1) &= R(t) + \delta_{I \rightarrow R}(t) - \delta_{R \rightarrow S}(t)\\
\end{aligned}
$$
We implement this process with two functions,`run_cb_sir()` and `cb_sir()`, and define a third function to collect the information we are interested in from each simulation, `return_obj()`. 

```{r SIRS-functions}
# implement chain binomial over time 
run_cb_sir = function(n_times, sims, IC, beta, gamma, rho){
  class = c("S", "I", "R", "C")
  ret = array(integer(),c(sims,length(class),n_times),dimnames = list(NULL, class, NULL))
  # ret dimensions - 1: sims, 2: classes, 3: time
  ret[,,1] = matrix(rep(IC,sims), nrow = sims, byrow = TRUE )
  # repeate cb_sir() over time
  for(ts in 2:n_times){
    ret[,,ts] <- cb_sir(sims,delta.t =1, 
                        S = ret[,"S",ts-1],  
                        I = ret[,"I",ts-1],
                        R = ret[,"R",ts-1],
                        C = ret[,"C",ts-1],
                        beta=beta,gamma=gamma,rho=rho)
  }
  # calculate metrics of interest based on simulations
  return(list(timeseries = ret, 
              metrics = return_obj(ret)))
}

# implement chain binomial for single time step
cb_sir <- function(S, I, R, C, beta, gamma, rho, 
                   sims, delta.t){
  N <- S+I+R
  # draw number of individuals transitioning between states
  dN_SI <- rbinom(n=sims,size=S,prob=1-exp(-beta*I/N*delta.t))
  dN_IR <- rbinom(n=sims,size=I,prob=1-exp(-gamma*delta.t))
  dN_RS <- rbinom(n=sims, size=R, prob=1-exp(-rho*delta.t))
  # update states
  S <- S - dN_SI + dN_RS
  I <- I + dN_SI - dN_IR
  R <- R + dN_IR - dN_RS
  C <- C + dN_SI
  return(cbind(S, I, R, C))
}

# calculate metrics of interest (cumulative & peak cases)
return_obj = function(out){
  # select only C compartment (cumulative cases over time)
  out <- reshape2::melt(out[,"C",], c("sim", "time"))
  setDT(out)
  # cumulative cases = # cases in C at final time
  cum_cases <- out[time == max(time),]
  cum_cases[,time :=NULL]
  setnames(cum_cases, "value", "cum_cases")
  # peak cases = max(diff between C at t and t-1)
  peak_cases <- out[, .(value = c(0,diff(value))), by = .(sim)]
  peak_cases <- peak_cases[, .(peak_cases = max(value)), by = .(sim)]
  return(left_join(peak_cases, cum_cases))
}
```

## Defining "multiple models"

We vary the parameters to represent four distinct models ($A$, $B$, $C$, and $D$) with varying assumptions about the transmission process. There are two types of uncertainty that these models encapsulate: 

1. **parametric  uncertainty** about the transmission rate, $\beta$. We assume that all four models let $\beta \sim N(\mu_\beta, 0.2)$ and that $\mu_\beta$ varies across models, with $\mu_{\beta,A} = 1.2$, $\mu_{\beta,B} = 1.4$, $\mu_{\beta,C} = 1.6$, and $\mu_{\beta,D} = 1.8$.
2. **structural uncertainty** about the waning of immunity, where models either assume transmission follows and SIR model (no waning of immunity, i.e., $rho = 0$) or that transmission follows and SIRS model (immunity wanes, we let $rho = 1/26$). We assume there are three ways in which structural uncertainty can be represented in our multi-model ensemble: 
    * structural uncertainty is *not represented*: all models assume no waning, i.e., $\rho_{A,B,C,D} = 0$
    * structural uncertainty is *represented between models*: two models assume no waning and two assume waning, i.e., $\rho_{A,C} = 0$ and $\rho_{B,D} = 1/26$
    * structural uncertainty is *represented within models*: all models incorporate both waning possibilities into their projections with equal probability, i.e., $\rho_{A,B,C,D} = [1/26,0]$
    
To implement these cases, we create a `data.frame` of individual model parameter sets to consider.

```{r define-parameters}
# define the number of simulations per model
n_samples <- 10000

# define mean and sd for transmission rate (beta) for each model
m1_beta <- 1.2; m2_beta <- 1.4; m3_beta <- 1.6; m4_beta <- 1.8
sig_beta <- 0.2

# define unique beta for each simulation
beta <- rnorm(n_samples*4, 
              c(rep(m1_beta, n_samples), 
                rep(m2_beta, n_samples),
                rep(m3_beta, n_samples),
                rep(m4_beta, n_samples)), 
              sd = sig_beta)
# verify all transmission rates are positive
which(beta <= 0)

# define unique recovery rate (gamma) for each simulation
mu_recov_time <- 1; sig_recov_time <- 0.1
recov_time <- rnorm(n_samples*4, mu_recov_time, sig_recov_time) 
# verify all recovery times are positive
which(recov_time <= 0)

# define unique waning rate (rho) for each simulation and structural uncertainty scenario
wane_time_unlikely <- 0; wane_time_likely <- 26

# structural uncertainty scenario 1: none
# no models consider structural uncertainty
rho_none <- rep(wane_time_unlikely, n_samples*4) 

# structural uncertainty scenario 2: between models
rho_btn <- c(rep(wane_time_unlikely, n_samples), # model A: waning unlikely
             rep(wane_time_likely, n_samples),   # model B: waning likely
             rep(wane_time_unlikely, n_samples), # model C: waning unlikely
             rep(wane_time_likely, n_samples))   # model D: waning likely
             

# structural uncertainty scenario 3: within models
# all models assume wanings/no waning with equal probability
rho_win <- rep(c(rep(wane_time_unlikely, n_samples/2), rep(wane_time_likely, n_samples/2)),4)

# create data.frame of parameters for each uncertainty scenario
# scenario 1: none
none <- data.frame(beta = beta, recov_time = recov_time,rho = rho_none, 
                   model = sort(rep(LETTERS[1:4], n_samples)),
                   struc_uncert = "none")
# scenario 2: between
btn <- data.frame(beta = beta, recov_time = recov_time, rho = rho_btn, 
                  model = sort(rep(LETTERS[1:4], n_samples)),
                  struc_uncert = "btn")
# scenario 3: within
win <- data.frame(beta = beta, recov_time = recov_time, rho = rho_win, 
                  model = sort(rep(LETTERS[1:4], n_samples)),
                  struc_uncert = "win")

# combine all parameters into one data.frame
all_params <- rbind(none, btn, win)
# correct any negative parameters and convert to rate
all_params$gamma = with(all_params, ifelse(recov_time == 0, 0, 1/recov_time))
all_params <- all_params %>% select(-recov_time)
all_params$rho = with(all_params, ifelse(rho == 0, 0, 1/rho))
# add simulation number
all_params$sim = 1:nrow(all_params)
```

Here are the distributions of parameters for each model:
```{r plot-params, echo = FALSE}
p_params <- all_params %>%
  mutate(R0 = beta/gamma, 
         model = paste("model", model)) %>%
  reshape2::melt(c("model", "struc_uncert", "sim")) %>%
  filter(variable != "rho", struc_uncert == "none") %>% # only need one struc scenario because all the same
  ggplot(aes(x = value, color = model)) + 
  geom_density(size = 1) + 
  facet_wrap(vars(variable), 
             labeller = label_parsed, 
             scales = "free",
             ncol = 3) +
  labs(x = "parameter value", y = "density", subtitle = "A: parametric uncertainty") +
  scale_color_brewer(palette = "Set1", direction = 0) + 
  theme_bw() + 
  theme(legend.position = "bottom", 
        legend.title = element_blank(),
        panel.grid = element_blank())
p_rho <-  all_params %>%
  mutate(rho = ifelse(rho == 0, "no waning", "waning")) %>%
  # change variables to factors for plotting
  mutate(struc_uncert = factor(struc_uncert, levels = c("none", "btn", "win"))) %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", 
                                      "not represented", 
                                      ifelse(struc_uncert == "btn", 
                                             "represented between models", 
                                             "represented within models")), 
                               levels = c("not represented","represented between models","represented within models")),
         model = paste("model", model)) %>% 
  group_by(model, struc_uncert, rho) %>%
  summarise(N_rho = n()) %>%
  ggplot(aes(x = model,y = N_rho, fill = rho)) + 
  geom_col(position = "stack") + 
  facet_wrap(vars(struc_uncert),
             ncol = 3, 
             strip.position = "bottom") +
  labs(x = "structural uncertainty assumption", y = "number of simulations", subtitle = "B: structural uncertainty") +
  #scale_alpha_manual(values = c(0.7,1)) +
  scale_fill_brewer(palette = "Paired", direction = 0, name = "model") + 
  theme_bw() + 
  theme(axis.title.x = element_blank(),
        legend.position = "bottom", 
        legend.title = element_blank(),
        panel.grid = element_blank(),
        panel.spacing = unit(0, "lines"),
        strip.background = element_blank(),
        strip.placement = "outside")
p_params <- plot_grid(p_params, p_rho, ncol = 1, axis = "lr", align = "vh")

ggsave(paste0(fig_path, "param_distributions.pdf"),p_params, width = 12, height = 9)

```

```{r plot-setup, include = FALSE}
# defnie base text size
bs <- 8

# define facet labels
labs_struc <- c("atop(Structural~uncertainty~bold(not~represented),all~models~assume~no~waning)", 
               "atop(Structural~uncertainty~bold(represented~between~models),A~and~C~asume~no~waning~B~and~D~assume~waning)", 
               "atop(Structural~uncertainty~bold(represented~within~models),all~models~consider~waning~and~no~waning)")
names(labs_struc) <- c("none", "btn", "win")


ub_labs <- list(bquote(mu[beta]==.(m1_beta)),
                bquote(mu[beta]==.(m2_beta)),
                bquote(mu[beta]==.(m3_beta)),
                bquote(mu[beta]==.(m4_beta)))

  
labs_struc_simp = c("Structural~uncertainty~bold(not~represented)",
                    "Structural~uncertainty~bold(represented~between~models)",
                    "Structural~uncertainty~bold(represented~within~models)")
names(labs_struc_simp) = c("none", "btn", "win")

labs_struc_super_simp <- c("not represented", "represented between models", "represented within models")
names(labs_struc_super_simp) = c("none", "btn", "win")

model_labs <- c(paste0("A:mu[beta]==",m1_beta,"~', '*rho==0"),
                paste0("B:mu[beta]==",m2_beta,"~', '*rho==0"),
                paste0("C:mu[beta]==",m3_beta,"~', '*rho==0"),
                paste0("D:mu[beta]==",m4_beta,"~', '*rho==0"),
                paste0("A:mu[beta]==",m1_beta,"~', '*rho==0"),
                paste0("B:mu[beta]==",m2_beta,"~', '*rho==1/26"),
                paste0("C:mu[beta]==",m3_beta,"~', '*rho==0"),
                paste0("D:mu[beta]==",m4_beta,"~', '*rho==1/26"),
                paste0("A:mu[beta]==",m1_beta,"~', '*rho==0*' or '*1/26"),
                paste0("B:mu[beta]==",m2_beta,"~', '*rho==0*' or '*1/26"),
                paste0("C:mu[beta]==",m3_beta,"~', '*rho==0*' or '*1/26"),
                paste0("D:mu[beta]==",m4_beta,"~', '*rho==0*' or '*1/26"))

# define colors
colrs_mod = rev(paste0("grey",round( seq(0.15, 0.85, length.out = 4),2)*100))
```

## Individual model projections

We simulate the model using all the parameter sets we've defined. To do so, we need to define the length of the simulation (52 weeks), population size (1000 individuals), and initial conditions (1.5% infected, all else susceptible).

```{r run-sims}
# other model parameters
T <- 52 # length of simulation  (in weeks)
N <- 1000 # number of individuals in the population
init = N*c(S = 0.985, I = 0.015, R = 0, C = 0) # initial conditions

# run the chain binomial model
out <- run_cb_sir(T, nrow(all_params), init , all_params$beta, all_params$gamma, all_params$rho)
# reshape out metrics
out$metrics <- out$metrics %>% left_join(all_params)
# reshape out time series
out$timeseries <- as.data.frame(out$timeseries[,"I",]) %>%
  mutate(id = 1:n()) %>%
  reshape2::melt("id") %>%
  rename(time = variable) %>%
  mutate(time = as.integer(gsub("V","",time)))
```

We plot the resulting simulations, which show outbreaks that either fade out or have a second wave depending on assumptions about waning immunity  (green: no waning, orange: waning).

```{r timeseries-individual-dists, fig.width=9, fig.height = 6, echo = FALSE}
plt <- out$timeseries %>%
  # pick a few sims randomly to improve plotting speed
  filter(id%%n_samples %in% sample(n_samples, 200)) %>%
  # add parameters to each row
  rename(sim = id) %>%
  left_join(all_params)
  
p_ts = plt %>%
  # change variables to factors for plotting
  mutate(struc_uncert = factor(struc_uncert, levels = c("none", "btn", "win"))) %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", 
                                      labs_struc_simp[1], 
                                      ifelse(struc_uncert == "btn", 
                                             labs_struc_simp[2], 
                                             labs_struc_simp[3])), 
                               levels = labs_struc_simp),
         model = model_labs[(as.numeric(struc_uncert)-1)*4 + as.numeric(as.factor(model))]) %>%
  ggplot(aes(x = time, y = value, group = sim, color = as.factor(rho))) + 
  geom_line(alpha = 0.05) + 
  facet_wrap(vars(struc_uncert, model), 
             labeller = label_parsed, 
             ncol = 4) +
  labs(x = "week", y = "number of infected individudals") +
  scale_color_brewer(palette = "Dark2", direction = 0, name = "") + 
  theme_bw() + 
  theme(legend.position = "none", 
        panel.grid = element_blank())
p_ts
ggsave(paste0(fig_path, "timeseries.pdf"),p_ts, width = 13, height = 9)

rm(plt)
```

Some simulations fade out early in the first wave, let's identify in how many simulations this occurs. 

```{r find-early-fadeouts}
inital_fadeout_thresh <- 100
kable(out$metrics %>% 
  group_by(model, struc_uncert) %>%
  #filter() %>%
  summarise(n = length(which((cum_cases < inital_fadeout_thresh)))))
```

Then, for each time series we track cumulative and peak cases. We summarize the output into distributions (both pdfs and cdfs) for each metric. For this vignette, we show results only for cumulative cases, though all analyses are performed for peak cases as well.  

```{r calc-individual-dists}
# convert to long format
out$metrics <- reshape2::melt(out$metrics, c("sim", "beta", "gamma", "rho", "model", "struc_uncert"))

# CDFs
q <- 1:99/100
cdfs <- setDT(out$metrics)[,.(value = quantile(value, q), quantile = q), 
            by = .(model, struc_uncert, variable)]

# PDFs
pdfs <- setDT(out$metrics)[,.(x = density(value, adjust = 2)$x, y = density(value, adjust = 2)$y),
                   by = .(model, struc_uncert, variable)]

```

We plot the distribution of outcomes for individual model projections across the three uncertainty scenarios. 

```{r plot-model-projections, fig.width=6, fig.height = 2.25, echo = FALSE}
# reorder factor 
pdfs$struc_uncert <- factor(pdfs$struc_uncert, levels = c("none", "btn", "win"))
pdfs$variable <- factor(pdfs$variable, levels = c("cum_cases", "peak_cases"))

# plot
p1_cumu <- pdfs %>% 
  filter(variable == "cum_cases") %>%
  mutate(struc_uncert = factor(struc_uncert, levels = names(labs_struc_super_simp))) %>%
  ggplot(aes(x = x, y = y)) +
  geom_path(aes(color = as.factor(model)), size= 0.5) +
  facet_grid(cols = vars(struc_uncert), 
             labeller = labeller(struc_uncert = labs_struc_super_simp)) +
  coord_cartesian(xlim = c(0,2000), 
                  ylim = range(pdfs %>% filter(variable == "cum_cases") %>% select(y)))+
  scale_color_manual(values = rev(colrs_mod),
                     labels = ub_labs) +
  scale_x_continuous(label = comma, 
                     name = "cumulative cases") +
  scale_y_continuous(expand = c(0,0),
                     name = "individual predictions\n(probability density function)") +
  theme_bw(base_size = bs) +
  theme(legend.key.size = unit(0.3, "cm"),
        legend.margin=margin(0,0,0,0),
        legend.text = element_text(size = rel(0.7)),
        legend.position = c(0.95,0.82),
        legend.title = element_blank(),
        panel.grid = element_blank(),
        strip.background = element_blank())
p1_cumu
```

## Aggregating outcomes
Next, we aggregate the outcomes of our multi-model simulation using both LOP and Vincent averages.

```{r aggregate}
# aggregate cdfs
agg_cdfs <- rbind(
  aggregate_cdfs(cdfs, id_var = "model", 
                 group_by = c("struc_uncert", "variable"),
                 method = "LOP", 
                 ret_quantiles = q)[,method:="LOP"],
  aggregate_cdfs(cdfs, id_var = "model", 
                 group_by = c("struc_uncert", "variable"),
                 method = "vincent", 
                 ret_quantiles = q)[,method := "Vincent"]
  )
  
# to get aggregate pdfs, sample from std. uniform and draw from distributions
agg_pdfs <- agg_cdfs[, .(samps = approx(quantile, value, runif(50000))$y), 
                     by = .(struc_uncert, variable, method)] %>%
  .[!is.na(samps)] %>%
  .[, .(x = density(samps, adjust = 1.5)$x, y = density(samps, adjust = 1.5)$y), 
    by = .(struc_uncert, variable, method)]
```

We plot the resulting aggregate distributions. 

```{r plot-aggs, fig.width=6, fig.height = 2.25, echo = FALSE}
# define aggregate colors
colrs_agg = c("#377EB8", "#ff7f00")

# plot
p2_cumu <- agg_pdfs %>% 
  filter(variable == "cum_cases") %>%
  mutate(struc_uncert = factor(struc_uncert, levels = names(labs_struc_simp))) %>%
  ggplot(aes(x = x, y = y)) + 
  geom_path(aes(color = method), size = 1, alpha = 0.8) +
  facet_grid(cols = vars(struc_uncert), 
             labeller = labeller(struc_uncert = labs_struc_super_simp)) +
  coord_cartesian(xlim = c(0,2000), 
                  ylim = range(pdfs %>% 
                                 filter(variable == "cum_cases") %>% 
                                 select(y)))+
  scale_color_manual(values = colrs_agg) +
  scale_x_continuous(label = comma, name = "cumulative cases") +
  scale_y_continuous(expand = c(0,0), name = "aggregate predictions\n(probability density function)") +
  theme_bw(base_size = bs) +
  theme(legend.key.height = unit(0.3, "cm"),
        legend.margin=margin(0,0,0,0),
        legend.position = c(0.94,0.85),
        legend.text = element_text(size = rel(0.7)),
        legend.title = element_blank(),
        panel.grid = element_blank(),
        strip.background = element_blank())
p2_cumu
```


## Evaluating performance

Next we test how well each of these aggregation methods perform, given a range of assumptions about the future. Our assumptions about the future transmission rate and waning of immunity are

| Truth case | True mean transmission rate | True waning of immunity |
|------------|------------------------|----------------------------- |
| case 1   | model A assumption is correct, $\mu_\beta = 1.2$ | no waning, SIR |
| case 2   | model B assumption is correct, $\mu_\beta = 1.4$ | no waning, SIR |
| case 3   | model C assumption is correct, $\mu_\beta = 1.6$ | no waning, SIR |
| case 4   | model D assumption is correct, $\mu_\beta = 1.8$ | no waning, SIR |
| case 5   | truth is mean of model assumptions, $\mu_\beta = 1.5$ | no waning, SIR |
| case 6   | model A assumption is correct, $\mu_\beta = 1.2$ |  waning, SIRS |
| case 7   | model B assumption is correct, $\mu_\beta = 1.4$ |  waning, SIRS |
| case 8   | model C assumption is correct, $\mu_\beta = 1.6$ |  waning, SIRS |
| case 9   | model D assumption is correct, $\mu_\beta = 1.8$ |  waning, SIRS |
| case 10   | truth is mean of model assumptions, $\mu_\beta = 1.5$ | waning, SIRS |

We define a `data.frame` with these true parameter values.

```{r future-obs}
# define the number of synthetic future observations
n_obs <- 1000
# define true transmission rate
obs_beta <- c(rnorm(n_obs, m1_beta, sig_beta),
              rnorm(n_obs, m2_beta, sig_beta),
              rnorm(n_obs, m3_beta, sig_beta),
              rnorm(n_obs, m4_beta, sig_beta),
              rnorm(n_obs, mean(c(m1_beta, m2_beta, m3_beta, m4_beta)),sig_beta))
# define true recovery rate
obs_recov_time <- rnorm(n_obs*5, mu_recov_time, sig_recov_time) 
# define true waning
obs_params <- rbind(data.frame(beta = obs_beta, obs_recov_time = obs_recov_time, rho = ifelse(wane_time_likely == 0, 0, 1/wane_time_likely), 
                               true_beta = sort(rep(c(paste0("m", 1:4), "mean"), n_obs)),
                               true_rho = "Y"),
                    data.frame(beta = obs_beta, obs_recov_time = 1/obs_recov_time, rho = ifelse(wane_time_unlikely == 0, 0, 1/wane_time_unlikely), 
                               true_beta = sort(rep(c(paste0("m", 1:4), "mean"), n_obs)),
                               true_rho = "N"))
obs_params$gamma = with(obs_params, ifelse(obs_recov_time == 0, 0, 1/obs_recov_time))
obs_params$sim = 1:nrow(obs_params)

# simulate observations given these true params
obs <- run_cb_sir(T, nrow(obs_params), init, obs_params$beta, obs_params$gamma, obs_params$rho)
obs <- obs$metrics
obs <- obs %>% left_join(obs_params) %>% select(-obs_recov_time)
obs <- reshape2::melt(obs, c("sim", "beta", "gamma", "rho", "true_beta", "true_rho"))
```

Doing so gives the following distribution of observations.

```{r, echo = FALSE, fig.width = 8, fig.height = 6}
labs_true_rho <- c("true waning:\nnone, SIR", "true waning:\n26 weeks, SIRS")
names(labs_true_rho) <- c("N", "Y")

labs_true_beta <- c("true transmission:\nA correct", 
                    "true transmission:\nB correct", 
                    "true transmission:\nC correct", 
                    "true transmission:\nD correct", 
                    "true transmission:\nmean")
names(labs_true_beta) <- c("m1", "m2", "m3", "m4", "mean")

fut_cum <- obs %>%
  filter(variable == "cum_cases") %>%
  ggplot() + 
  geom_density(aes(x = value)) +
  facet_grid(cols = vars(true_rho), 
             rows = vars(true_beta),
             labeller = labeller(true_beta = labs_true_beta, 
                                 true_rho = labs_true_rho), 
             switch = "y") +
  labs(x = "observed cumulative cases", linetype = "true waning") +
  scale_x_continuous(labels = comma) +
  theme_bw()+
  theme(axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        axis.title.y = element_blank(),
        legend.position = "bottom", 
        panel.grid = element_blank(), 
        strip.background = element_blank(), 
        strip.placement = "outside")
fut_cum

fut_peak <- obs %>%
  filter(variable == "peak_cases") %>%
  ggplot() + 
  geom_density(aes(x = value)) +
  facet_grid(cols = vars(true_rho), 
             rows = vars(true_beta),
             labeller = labeller(true_beta = labs_true_beta, 
                                 true_rho = labs_true_rho), 
             switch = "y") +
  labs(x = "observed peak cases", linetype = "true waning") +
  scale_x_continuous(labels = comma) +
  theme_bw()+
  theme(axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(), 
        axis.title.y = element_blank(),
        legend.position = "bottom", 
        panel.grid = element_blank(), 
        strip.background = element_blank(), 
        strip.placement = "outside")
```


We use the continuous rank probability score (CRPS) [@matheson_scoring_1976-1] to assess performance of the aggregate distributions against these synthetic future observations.

```{r crps}
# define function to implement CRPS 
u1 = runif(10000)
u2 = runif(10000)
CRPS <- function(q,v,o,rule=2, ties="ordered") {
  x = approx(q,v,u1,rule=rule, ties=ties)
  return(mean(abs(x$y-o[1])) - 1/2*mean(abs(x$y-approx(q,v,u2,rule=rule, ties=ties)$y)))
}

# implement CRPS
scores <- obs %>%
  select(variable, value) %>%
  unique() %>%
  rename(obs = value) %>%
  mutate(obs_num = 1:length(obs)) %>%
  dplyr::left_join(agg_cdfs)
# get CRPS score
scores <- setDT(scores)[, .(CRPS = CRPS(quantile,value,obs)), 
                   by=.(method, variable, struc_uncert, obs_num, obs)]
```

The CRPS results can be plotted for the LOP and Vincent aggregates across three structural uncertainty scenarios. 

```{r plot-CRPS, echo = FALSE, fig.width = 9, fig.height = 4}
crps_cum <- scores %>%
  filter(variable == "cum_cases") %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", labs_struc_simp[1], ifelse(struc_uncert == "btn", labs_struc_simp[2], labs_struc_simp[3])), levels = labs_struc_simp)) %>%
  ggplot(aes(x = obs, y = CRPS, color = method)) + 
  geom_line(size = 0.8) + 
  facet_grid(cols = vars(struc_uncert), 
             labeller = label_parsed) +
  labs(x = "observed cumulative cases", color = "aggregate") +
  scale_color_manual(values = colrs_agg) + 
  scale_x_continuous(labels = comma) +
  theme_bw() + 
  theme(legend.position = c(0.92,0.86), 
        legend.title = element_blank(),
        panel.grid = element_blank(), 
        strip.background = element_blank())
crps_cum

crps_peak <- scores %>%
  filter(variable == "peak_cases") %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", labs_struc_simp[1], ifelse(struc_uncert == "btn", labs_struc_simp[2], labs_struc_simp[3])), levels = labs_struc_simp)) %>%
  ggplot(aes(x = obs, y = CRPS, color = method)) + 
  geom_line(size = 0.8) + 
  facet_grid(cols = vars(struc_uncert), 
             labeller = label_parsed) +
  labs(x = "observed peak cases", color = "aggregate") +
  scale_color_manual(values = colrs_agg) + 
  scale_x_continuous(labels = comma) +
  theme_bw() + 
  theme(legend.position = c(0.92,0.86), 
        legend.title = element_blank(),
        panel.grid = element_blank(), 
        strip.background = element_blank())
```

And we can show when LOP and Vincent perform better by plotting the difference between CRPS for each. 

```{r plot-CRPS-diff, fig.width = 9, fig.height = 4}
crps_diff_cum <- scores %>%
  filter(variable == "cum_cases") %>%
  reshape2::dcast(struc_uncert + obs + obs_num ~ method, value.var = "CRPS") %>%
  mutate(diff = Vincent - LOP) %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", labs_struc_simp[1], ifelse(struc_uncert == "btn", labs_struc_simp[2], labs_struc_simp[3])), levels = labs_struc_simp)) %>%
  ggplot(aes(x = obs, y = diff)) + 
  geom_hline(aes(yintercept = 0), linetype = "dotted", size = 0.3) +
  geom_line() +
  geom_text(data = data.frame(x = c(0, 0 ),
                              y  = c(50,-50), 
                              lab = c("LOP performs better", "Vincent performs better"), 
                              struc_uncert = rep(labs_struc_simp[1], 2)), 
            aes(x = x, y = y, label = lab, color = lab), angle = 90, size = 3, vjust = 0) +
  facet_grid(cols = vars(struc_uncert), 
             labeller = label_parsed) +
  labs(x = "observed cumulative cases", y = "CRPS(Vincent) - CRPS(LOP)") +
  scale_color_manual(values = colrs_agg) + 
  scale_x_continuous(labels = comma) +
  theme_bw() + 
  theme(legend.position = "none", 
        panel.grid = element_blank(), 
        strip.background = element_blank())
crps_diff_cum

crps_diff_peak <- scores %>%
  filter(variable == "peak_cases") %>%
  reshape2::dcast(struc_uncert + obs + obs_num ~ method, value.var = "CRPS") %>%
  mutate(diff = Vincent - LOP) %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", labs_struc_simp[1], ifelse(struc_uncert == "btn", labs_struc_simp[2], labs_struc_simp[3])), levels = labs_struc_simp)) %>%
  ggplot(aes(x = obs, y = diff)) + 
  geom_hline(aes(yintercept = 0), linetype = "dotted", size = 0.3) +
  geom_line() +
  geom_text(data = data.frame(x = c(0, 0 ),
                              y  = c(50,-50), 
                              lab = c("LOP performs better", "Vincent performs better"), 
                              struc_uncert = rep(labs_struc_simp[1], 2)), 
            aes(x = x, y = y, label = lab, color = lab), angle = 90, size = 3, vjust = 0) +
  facet_grid(cols = vars(struc_uncert), 
             labeller = label_parsed) +
  labs(x = "observed peak cases", y = "CRPS(Vincent) - CRPS(LOP)") +
  scale_color_manual(values = colrs_agg) + 
  scale_x_continuous(labels = comma) +
  theme_bw() + 
  theme(legend.position = "none", 
        panel.grid = element_blank(), 
        strip.background = element_blank())

```

Then, if we combine these score differences with the frequency at which each observation occurs in the synthetic observations, we can generate a distribution of relative performance. We summarize that distribution with a few intervals.  

```{r rel-perf}
scores_all <- obs %>%
  left_join(scores, by = c("variable", "value" = "obs")) %>%
  reshape2::dcast(variable + true_beta + true_rho + struc_uncert + 
                    value + sim ~ method, value.var = "CRPS") %>%
  # calculate difference to see which method has better CRPS
  mutate(diff = Vincent - LOP) %>%
  # summarize distribution of differences
  group_by(variable, true_beta, true_rho, struc_uncert) %>%
  mutate(lower = quantile(diff, 0.025),
      lower_25 = quantile(diff, 0.25), 
      med = median(diff),
      upper_75 = quantile(diff, 0.75),
      upper = quantile(diff, 0.975), 
      # for plotting
      plot_y = factor(true_beta)) %>%
  mutate(plot_y = as.numeric(plot_y))
```

```{r plot-CRPS2, echo = FALSE, fig.width=9, fig.height = 5}
# define labels
labs_m = 1:5
names(labs_m) = as.character(c(m1_beta, m2_beta, m3_beta, m4_beta, 
                             mean(c(m1_beta, m2_beta, m3_beta, m4_beta))))

labs_rho = c("26-week waning immunity, SIRS", "no waning immunity, SIR")
names(labs_rho) = c("Y", "N")

# plot
p3_cumu = scores_all %>% 
  filter(variable == "cum_cases") %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", labs_struc_simp[1], ifelse(struc_uncert == "btn", labs_struc_simp[2], labs_struc_simp[3])), levels = labs_struc_simp)) %>%
  ggplot() +
  geom_vline(aes(xintercept = 0), color = "grey") +
  geom_text(data = data.frame(x = c(5,-5),
                              y = c(0.5,0.5),
                              lab = c("LOP performs better", "Vincent performs better"),
                              hjust = c(0,1),
                              obs_rho = 26),
            aes(x = x, y = y, label = lab, hjust = hjust, color = lab), size = 2.3) +
  geom_segment(aes(x = lower_25, y = plot_y, xend = upper_75, yend = plot_y), size = 1.5) +
  geom_pointrange(aes(x = med, y = plot_y, xmin = lower, xmax = upper)) +
  facet_grid(cols = vars(struc_uncert), rows = vars(true_rho), switch = "y", 
             labeller = labeller(true_rho = labs_rho, struc_uncert = label_parsed)) +
  scale_color_manual(values = colrs_agg) +
  scale_x_continuous(limits = c(-max(abs(c(scores_all$lower, scores_all$upper))), 
                                max(abs(c(scores_all$lower, scores_all$upper)))),
                     name = "CRPS(Vincent) - CRPS(LOP)") +
  scale_y_reverse(breaks = labs_m, 
                  labels = names(labs_m), 
                  name = "Assumptions about future observations") +
  theme_bw()+
  theme(#axis.title.y = element_blank(),
        legend.position = "none",
        panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.placement = "outside")
p3_cumu

p3_peak = scores_all %>% 
  filter(variable == "peak_cases") %>%
  mutate(struc_uncert = factor(ifelse(struc_uncert == "none", labs_struc_simp[1], ifelse(struc_uncert == "btn", labs_struc_simp[2], labs_struc_simp[3])), levels = labs_struc_simp)) %>%
  ggplot() +
  geom_vline(aes(xintercept = 0), color = "grey") +
  geom_text(data = data.frame(x = c(5,-5),
                              y = c(0.5,0.5),
                              lab = c("LOP performs better", "Vincent performs better"),
                              hjust = c(0,1),
                              obs_rho = 26),
            aes(x = x, y = y, label = lab, hjust = hjust, color = lab), size = 2.3) +
  geom_segment(aes(x = lower_25, y = plot_y, xend = upper_75, yend = plot_y), size = 1.5) +
  geom_pointrange(aes(x = med, y = plot_y, xmin = lower, xmax = upper)) +
  facet_grid(cols = vars(struc_uncert), rows = vars(true_rho), switch = "y", 
             labeller = labeller(true_rho = labs_rho, struc_uncert = label_parsed)) +  scale_color_manual(values = colrs_agg) +
  scale_x_continuous(limits = c(-max(abs(c(scores_all$lower, scores_all$upper))), 
                                max(abs(c(scores_all$lower, scores_all$upper)))),
                     name = "CRPS(Vincent) - CRPS(LOP)") +
  scale_y_reverse(breaks = labs_m, 
                  labels = names(labs_m), 
                  name = "Assumptions about future observations") +
  theme_bw()+
  theme(#axis.title.y = element_blank(),
        legend.position = "none",
        panel.grid = element_blank(),
        strip.background = element_blank(),
        strip.placement = "outside")
```

```{r Fig3, include = FALSE, fig.width=12, fig.height = 10}
struc_text_plot <- ggplot(data = data.frame(x = c(0,1),
                           y = c(0,0))) + 
    geom_line(aes(x = x, y = y), size = 0.25)+
    geom_label(aes(x = 0.5, y = 0, label = "structural uncertainty"),
              label.size = NA, size = bs/3)+
    theme_nothing()

plot_grid(
 struc_text_plot,
  p1_cumu +
    geom_text(data = data.frame(x = rep(0,3),
                              y = rep(0.013, 3),
                              lab = c("(a)", "(b)", "(c)"),
                              struc_uncert = factor(names(labs_struc_super_simp),
                                                    levels = names(labs_struc_super_simp))),
            aes(x = x, y = y, label = lab), vjust = 1, size = bs/3) +
    theme(axis.text = element_blank(), 
          axis.ticks.y = element_blank(), 
          axis.title.x = element_blank(),
          axis.title.y = element_text(size = bs)),
  p2_cumu + 
    geom_text(data = data.frame(x = rep(0,3),
                              y = rep(0.013, 3),
                              lab = c("(d)", "(e)", "(f)"),
                              struc_uncert = factor(names(labs_struc_super_simp),
                                                    levels = names(labs_struc_super_simp))),
            aes(x = x, y = y, label = lab), vjust = 1, size = bs/3) + 
    theme(axis.text.y = element_blank(), 
          axis.ticks.y = element_blank(), 
          strip.text = element_blank()),
  ncol = 1, rel_heights = c(0.05,0.45, 0.45), axis = "lr", align = "vh"
)

ggsave(paste0(fig_path,"pdfs_scores_cum.pdf"), width = 6, height = 4 , units = "in")
```


```{r Fig4, include = FALSE, fig.width=12, fig.height = 4}
F4a = pdfs %>% 
  filter(variable == "peak_cases") %>%
  mutate(struc_uncert = factor(struc_uncert, levels = names(labs_struc_super_simp))) %>%
  ggplot(aes(x = x, y = y)) +
  geom_path(aes(color = as.factor(model)), size= 0.5) +
  geom_path(data = agg_pdfs %>% 
              filter(variable == "peak_cases") %>%
              mutate(struc_uncert = factor(struc_uncert, levels = names(labs_struc_super_simp))), 
            aes(color =  method), size = 1) +
  geom_text(data = data.frame(x = rep(-Inf,3),
                              y = rep(Inf, 3),
                              lab = c("(a)", "(b)", "(c)"),
                              struc_uncert = factor(names(labs_struc_super_simp),
                                                    levels = names(labs_struc_super_simp))),
            aes(x = x, y = y, label = lab), hjust = 0, vjust = 1, size = bs/3) +
  facet_grid(cols = vars(struc_uncert), 
             labeller = labeller(struc_uncert = labs_struc_super_simp)) +
  scale_color_manual(labels = c(ub_labs, "LOP", "Vincent"), 
                     values = c(rev(colrs_mod), colrs_agg)) +
  scale_x_continuous(expand = c(0.005,0),
                     label = comma, 
                     name = "peak cases") +
  scale_y_continuous(expand = c(0,0,0.05, 0), 
                     name = "individual and aggregate predictions\n(probability density function)") +
  theme_bw(base_size = 8) +
  theme(axis.text.y = element_blank(), 
        axis.ticks.y = element_blank(),
        legend.key.size = unit(0.3, "cm"),
        legend.margin=margin(0,0,0,0),
        legend.text = element_text(size = rel(0.7)),
        legend.position = c(0.95,0.75),
        legend.title = element_blank(),
        panel.grid = element_blank(),
        strip.background = element_blank()) 
  
plot_grid(struc_text_plot, F4a, 
           ncol = 1, rel_heights = c(0.05,0.95), axis = "lr", align = "vh")

ggsave(paste0(fig_path,"pdfs_scores_peak.pdf"), width = 6, height = 2.2 , units = "in")
```

```{r supp, include = FALSE}
p2 <- plot_grid(crps_cum +
            labs(subtitle = "B: Continuous rank probability score (CRPS)"), 
          crps_diff_cum+
            labs(subtitle = "C: Difference in CRPS"), 
          ncol = 1)
p2 <- plot_grid(fut_cum + 
            labs(subtitle = "A: Synthetic future observations"), 
          p2, nrow = 1, rel_widths = c(0.3,0.7))
plot_grid(p2, 
          p3_cumu + 
            labs(subtitle = "D: Distribution of CRPS difference"), ncol = 1, rel_heights = c(0.6,0.4))

ggsave(paste0(fig_path,"crps_diff_cum.pdf"), width = 15, height = 12 , units = "in")


p2 <- plot_grid(crps_peak +
            labs(subtitle = "B: Continuous rank probability score (CRPS)"), 
          crps_diff_peak+
            labs(subtitle = "C: Difference in CRPS"), 
          ncol = 1)
p2 <- plot_grid(fut_peak + 
            labs(subtitle = "A: Synthetic future observations"), 
          p2, nrow = 1, rel_widths = c(0.3,0.7))
plot_grid(p2, 
          p3_peak + 
            labs(subtitle = "D: Distribution of CRPS difference"), ncol = 1, rel_heights = c(0.6,0.4))

ggsave(paste0(fig_path,"crps_diff_peak.pdf"), width = 15, height = 12 , units = "in")
```


```{r supp-othercase, include = FALSE}
# structural uncertainty case 4: all models assume waning immunity
rho_all <- rep(wane_time_likely, n_samples*4)
supp_params <- data.frame(beta = beta, recov_time = recov_time,rho = rho_all, 
                   model = sort(rep(LETTERS[1:4], n_samples)),
                   struc_uncert = "all")
# correct any negative parameters and convert to rate
supp_params$gamma = with(supp_params, ifelse(recov_time == 0, 0, 1/recov_time))
supp_params$rho = with(supp_params, ifelse(rho == 0, 0, 1/rho))
# add simulation number
supp_params$sim = 1:nrow(supp_params)

# run the chain binomial model
supp_out <- run_cb_sir(T, nrow(supp_params), init , supp_params$beta, supp_params$gamma, supp_params$rho)
# reshape supp_out metrics
supp_out$metrics <- supp_out$metrics %>% left_join(supp_params)
# reshape supp_out time series
supp_out$timeseries <- as.data.frame(supp_out$timeseries[,"I",]) %>%
  mutate(id = 1:n()) %>%
  reshape2::melt("id") %>%
  rename(time = variable) %>%
  mutate(time = as.integer(gsub("V","",time)))

# calculate individual distributions
# convert to long format
supp_out$metrics <- reshape2::melt(supp_out$metrics, c("sim", "beta", "gamma", "rho", "model", "struc_uncert"))
# CDFs
q <- 1:99/100
supp_cdfs <- setDT(supp_out$metrics)[,.(value = quantile(value, q), quantile = q), 
            by = .(model, struc_uncert, variable)]
# PDFs
supp_pdfs <- setDT(supp_out$metrics)[,.(x = density(value, adjust = 2)$x, y = density(value, adjust = 2)$y),
                   by = .(model, struc_uncert, variable)]

# aggregate
supp_agg_cdfs <- rbind(
  aggregate_cdfs(supp_cdfs, id_var = "model", 
                 group_by = c("struc_uncert", "variable"),
                 method = "LOP", 
                 ret_quantiles = q)[,method:="LOP"],
  aggregate_cdfs(supp_cdfs, id_var = "model", 
                 group_by = c("struc_uncert", "variable"),
                 method = "vincent", 
                 ret_quantiles = q)[,method := "Vincent"]
  )
  
# to get aggregate pdfs, sample from std. uniform and draw from distributions
supp_agg_pdfs <- supp_agg_cdfs[, .(samps = approx(quantile, value, runif(50000))$y), 
                     by = .(struc_uncert, variable, method)] %>%
  .[!is.na(samps)] %>%
  .[, .(x = density(samps, adjust = 1.5)$x, y = density(samps, adjust = 1.5)$y), 
    by = .(struc_uncert, variable, method)]

pa <- supp_pdfs %>% 
  filter(variable == "cum_cases" & struc_uncert == "all") %>%
  mutate(struc_uncert = factor(struc_uncert, levels = names(labs_struc_super_simp))) %>%
  ggplot(aes(x = x, y = y)) +
  geom_path(aes(color = as.factor(model)), size= 0.5) +
  facet_grid(cols = vars(struc_uncert)) +
  coord_cartesian(xlim = c(0,2000), 
                  ylim = range(pdfs %>% filter(variable == "cum_cases") %>% select(y)))+
  scale_color_manual(values = rev(colrs_mod),
                     labels = ub_labs) +
  scale_x_continuous(label = comma, 
                     name = "cumulative cases") +
  scale_y_continuous(expand = c(0,0),
                     name = "individual predictions\n(probability density function)") +
  theme_bw(base_size = bs) +
  theme(legend.key.size = unit(0.3, "cm"),
        legend.margin=margin(0,0,0,0),
        legend.text = element_text(size = rel(0.7)),
        legend.position = c(0.92,0.89),
        legend.title = element_blank(),
        panel.grid = element_blank(),
        strip.background = element_blank(), 
        strip.text = element_blank())

pb <- supp_agg_pdfs %>% 
  filter(variable == "cum_cases") %>%
  mutate(struc_uncert = factor(struc_uncert, levels = names(labs_struc_simp))) %>%
  ggplot(aes(x = x, y = y)) + 
  geom_path(aes(color = method), size = 1, alpha = 0.8) +
  coord_cartesian(xlim = c(0,2000), 
                  ylim = range(pdfs %>% 
                                 filter(variable == "cum_cases") %>% 
                                 select(y)))+
  scale_color_manual(values = colrs_agg) +
  scale_x_continuous(label = comma, name = "cumulative cases") +
  scale_y_continuous(expand = c(0,0), name = "aggregate predictions\n(probability density function)") +
  theme_bw(base_size = bs) +
  theme(legend.key.height = unit(0.3, "cm"),
        legend.margin=margin(0,0,0,0),
        legend.position = c(0.9,0.89),
        legend.text = element_text(size = rel(0.7)),
        legend.title = element_blank(),
        panel.grid = element_blank(),
        strip.background = element_blank())

plot_grid(pa, pb, nrow = 1)
ggsave(paste0(fig_path,"all_waning_pdfs.pdf"), width = 10, height = 5 , units = "in")
```

```{r values-for-text, include = FALSE}
# percent of cumu case observations where LOP performs better
# structural uncertainty = btn only
obs %>%
  left_join(scores, by = c("variable", "value" = "obs")) %>%
  reshape2::dcast(variable + true_beta + true_rho + struc_uncert + 
                    value + sim ~ method, value.var = "CRPS") %>%
  mutate(LOP_better_flag = ifelse(LOP > Vincent, 0, 1)) %>%
  filter(variable == "cum_cases", struc_uncert == "btn") %>%
  summarise(pct_LOP = sum(LOP_better_flag)/n(), 
            pct_Vin = 1-pct_LOP)


# percent of peak case observations where vincent performs better
obs %>%
  left_join(scores, by = c("variable", "value" = "obs")) %>%
  reshape2::dcast(variable + true_beta + true_rho + struc_uncert + 
                    value + sim ~ method, value.var = "CRPS") %>%
  mutate(LOP_better_flag = ifelse(LOP > Vincent, 0, 1)) %>%
  filter(variable == "peak_cases") %>%
  summarise(pct_LOP = sum(LOP_better_flag)/n(), 
            pct_Vin = 1-pct_LOP)

# percent of peak case observations where vincent performs better 
# true transmission = model mean only
obs %>%
  left_join(scores, by = c("variable", "value" = "obs")) %>%
  reshape2::dcast(variable + true_beta + true_rho + struc_uncert + 
                    value + sim ~ method, value.var = "CRPS") %>%
  mutate(LOP_better_flag = ifelse(LOP > Vincent, 0, 1)) %>%
  filter(variable == "peak_cases", true_beta == "mean") %>%
  summarise(pct_LOP = sum(LOP_better_flag)/n(), 
            pct_Vin = 1-pct_LOP)

```

## References
