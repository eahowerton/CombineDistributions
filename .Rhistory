roxygenize()
roxygenize(vincent.R)
roxygenize("vincent.R")
roxygenize("~vincent.R")
prompt(calculate_aggregate_vin)
#' Implement quantile averaging
#'
#' Given a set of cumulative distribution functions  (assume for now: defined on same values),
#'   combine using quantile averaging (also called Vincent average).
#'   This method calculates the (weighted) average of values at a given quantile
#'
#' @param dat data.frame containing cdfs to be combined. See details for structure.
#' @param ret_quantiles A matrix with length(x) rows, and n columns where n is the number of distrbutions to combine
#' @return vin A data.frame with \code{quantile} and \code{value} of quantile averaged aggregate.
#'
#' @details \code{dat} should contain three columns, named \code{id}, \code{quantile}, and \code{value}.
#' \code{id} contains identifiers to distinguish between different individual cdfs.
#' \code{quantile} contains quantiles (between 0 and 1) and \code{value} contains the cdf value for that model and quantile.
#'
#' @example
#' dat <- expand.grid(id = c("A", "B"),
#'                    quantile = seq(0,1,0.01))
#' dat$value <- ifelse(dat$id == "A", qnorm(dat$quantile), qnorm(dat$quantile, 0,2))
#' calculate_aggregate_vin(dat, seq(0,1,0.05))
calculate_aggregate_vin <- function(dat, ret_quantiles){ #model_weights
#dat <- left_join(dat, model_weights)
# calcualte vincent average
vinc <- dat %>%
tidyverse::group_by(quantile) %>%
tidyverse::summarise(value= mean(value))
# return specified quantiles
if(all(round(ret_quantiles,4) %in% round(unique(vinc$quantile),4))){ # rounding probably not the best way to handle
return(vinc %>% tidyverse::filter(round(quantile,4) %in% round(ret_quantiles,4)))
}
else{
warning("more quantiles to return than provided, interpolating missing quantiles")
vinc_interp <- approx(vinc$quantile, vinc$value, xout = ret_quantiles)
vinc <- tibble(quantile = vinc_interp$x,
value = vinc_interp$y)
return(vinc)
}
}
prompt(calculate_aggregate_vin)
usethis::use_testthat()
devtools::test()
load_all()
library(devtools)
load_all()
library(devtools)
has_devel  ()
use_pipe()
document()
source('~/Documents/GitHub/CombineDistributions/R/implement_aggregation.R')
document()
rm(list = c("calculate_aggregate_vin"))
load_all
document()
document
document()
previewRd("calculate_aggregate_vin.Rd")
library(rstudioapi)
previewRd("calculate_aggregate_vin.Rd")
previewRD("calculate_aggregate_vin.Rd")
preview("calculate_aggregate_vin.Rd")
document()
devtools::load_all(".")
?calculate_aggregate_vin()
?calculate_aggregate_vin()
source('~/Documents/GitHub/CombineDistributions/R/LOP.R', echo=TRUE)
?create_interp_fns
document()
?calculate_aggregate_LOP
?create_interp_fns
?evaluate_cdf
?trim_cdf
?avg_probs
?avg_probs
?mean_trim
library(CombineDistributions)
devtools::load_all(".")
use_description()
library(usethis)
use_description()
use_description()
use_package(dplyr)
use_package("dplyr")
use_package("tibble")
use_package("reshape2")
devtools::load_all(".")
require(tibble)
library(CombineDistributions)
@import tibble
df_cdfs <- data.frame(quantile = c(0,0.5,0.5,1,0,1),
value = c(1,1,2,2,3,3))
avg_probs(df_cdfs)
load_all()
devtools::load_all(".")
avg_probs(df_cdfs)
library("testthat")
test_file("test_determine_trim_vals.R")
test_file("~tests/test_determine_trim_vals.R")
test_file("~tests/test_determine_trim_vals.R")
test_file("~tests/testthat/test_determine_trim_vals.R")
test_file("tests/testthat/test_determine_trim_vals.R")
#' Setup exterior trimming
#'
#' For exterior trimming, remove \code{n_trim/2} lowest and highest values.
#'
#' @inheritParams keep_vals
#' @return list containing two elements: (1) vector of values to keep;
#'   (2) number of ids trimmed
#'
#' @examples
#' keep_vals_exterior(2, 4)
#' keep_vals_exterior(4, 5)
keep_vals_exterior <- function(n_trim, n_ids){
n_trim_per_side <- n_trim/2
keep <- (n_trim_per_side+1):(n_ids-n_trim_per_side)
return(list(keep = keep, n_trim = n_trim))
}
#### keep_vals_exterior() ####
test_that("Test keep_vals_exterior(): odd number of models",{
## odd number of models
n_models <- 5
# check keep
expect_setequal(keep_vals_exterior(1, n_models)[["keep"]] , 2:4)
expect_setequal(keep_vals_exterior(2, n_models)[["keep"]] , 3)
# check n_trim
expect_equal(keep_vals_exterior(1, n_models)[["n_trim"]] , 2)
expect_equal(keep_vals_exterior(2, n_models)[["n_trim"]] , 4)
})
#### keep_vals_exterior() ####
test_that("Test keep_vals_exterior(): odd number of models",{
## odd number of models
n_models <- 5
# check keep
expect_setequal(keep_vals_exterior(2, n_models)[["keep"]] , 2:4)
expect_setequal(keep_vals_exterior(4, n_models)[["keep"]] , 3)
# check n_trim
expect_equal(keep_vals_exterior(2, n_models)[["n_trim"]] , 2)
expect_equal(keep_vals_exterior(4, n_models)[["n_trim"]] , 4)
})
test_that("Test keep_vals_exterior(): even number of models",{
## even number of models
n_models <- 6
# check keep
expect_setequal(keep_vals_exterior(1, n_models)[["keep"]] , 2:5)
expect_setequal(keep_vals_exterior(2, n_models)[["keep"]] , 3:4)
# check n_trim
expect_equal(keep_vals_exterior(1, n_models)[["n_trim"]] , 2)
expect_equal(keep_vals_exterior(2, n_models)[["n_trim"]] , 4)
})
test_that("Test keep_vals_exterior(): even number of models",{
## even number of models
n_models <- 6
# check keep
expect_setequal(keep_vals_exterior(2, n_models)[["keep"]] , 2:5)
expect_setequal(keep_vals_exterior(4, n_models)[["keep"]] , 3:4)
# check n_trim
expect_equal(keep_vals_exterior(2, n_models)[["n_trim"]] , 2)
expect_equal(keep_vals_exterior(4, n_models)[["n_trim"]] , 4)
})
test_that("Test keep_vals_interior: even number of models",{
n_models <- 6
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,5,6))
expect_setequal(keep_vals_interior(2, n_models)[["keep"]] , c(1,2,5,6))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 2)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 2)
})
rm(keep_vals_exterior())
rm(keep_vals_exterior
)
#### keep_vals_interior() ####
test_that("Test keep_vals_interior: odd number of models",{
n_models <- 5
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,4,5))
expect_setequal(keep_vals_interior(2, n_models)[["keep"]] , c(1,5))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 1)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 3)
})
test_file("tests/testthat/test_determine_trim_vals.R")
test_file("tests/testthat/test_determineTrimVals.R")
test_file("tests/testthat/test_LOP.R")
#' Setup interior trimming
#'
#' For interior trimming, remove innermost \code{n_trim} values.
#'
#' @inheritParams keep_vals
#' @return list containing two elements: (1) vector of values to keep;
#'   (2) number of ids trimmed
#'
#' @details Interior trimming requires (1) \code{n_trim < n_ids} and
#' (2) \code{n_trim} and \code{n_ids} have the same parity
#' (i.e., both are even or both are odd). If not,
#'  \code{n_trim} is increased to \code{n_trim + 1}.
#'
#' @examples
#' keep_vals_interior(2, 4)
#' keep_vals_interior(1, 4)
keep_vals_interior <- function(n_trim, n_ids){
num_keep <- (n_ids-n_trim)/2
keep <- c(1:num_keep, (n_ids-num_keep+1):n_ids)
return(list(keep = keep, n_trim = n_trim))
}
#### keep_vals_interior() ####
test_that("Test keep_vals_interior: odd number of models",{
n_models <- 5
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,4,5))
expect_setequal(keep_vals_interior(2, n_models)[["keep"]] , c(1,5))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 1)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 3)
})
#### keep_vals_interior() ####
test_that("Test keep_vals_interior: odd number of models",{
n_models <- 5
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,4,5))
expect_setequal(keep_vals_interior(2, n_models)[["keep"]] , c(1,2,4,5))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 1)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 3)
})
keep_vals_interior(1, n_models)
n_models <- 5
keep_vals_interior(1, n_models)[["keep"]]
expect_setequal(keep_vals_interior(2, n_models)[["keep"]] , c(1,5))
keep_vals_interior(2, n_models)
#' Setup interior trimming
#'
#' For interior trimming, remove innermost \code{n_trim} values.
#'
#' @inheritParams keep_vals
#' @return list containing two elements: (1) vector of values to keep;
#'   (2) number of ids trimmed
#'
#' @details Interior trimming requires (1) \code{n_trim < n_ids} and
#' (2) \code{n_trim} and \code{n_ids} have the same parity
#' (i.e., both are even or both are odd). If not,
#'  \code{n_trim} is increased to \code{n_trim + 1}.
#'
#' @examples
#' keep_vals_interior(2, 4)
#' keep_vals_interior(1, 4)
keep_vals_interior <- function(n_trim, n_ids){
browser()
num_keep <- (n_ids-n_trim)/2
keep <- c(1:num_keep, (n_ids-num_keep+1):n_ids)
return(list(keep = keep, n_trim = n_trim))
}
keep_vals_interior(2, n_models)
#### keep_vals_interior() ####
test_that("Test keep_vals_interior: odd number of models",{
n_models <- 5
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,4,5))
expect_setequal(keep_vals_interior(3, n_models)[["keep"]] , c(1,5))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 1)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 3)
})
``
q
quit()
#' Setup interior trimming
#'
#' For interior trimming, remove innermost \code{n_trim} values.
#'
#' @inheritParams keep_vals
#' @return list containing two elements: (1) vector of values to keep;
#'   (2) number of ids trimmed
#'
#' @details Interior trimming requires (1) \code{n_trim < n_ids} and
#' (2) \code{n_trim} and \code{n_ids} have the same parity
#' (i.e., both are even or both are odd). If not,
#'  \code{n_trim} is increased to \code{n_trim + 1}.
#'
#' @examples
#' keep_vals_interior(2, 4)
#' keep_vals_interior(1, 4)
keep_vals_interior <- function(n_trim, n_ids){
num_keep <- (n_ids-n_trim)/2
keep <- c(1:num_keep, (n_ids-num_keep+1):n_ids)
return(list(keep = keep, n_trim = n_trim))
}
#### keep_vals_interior() ####
test_that("Test keep_vals_interior: odd number of models",{
n_models <- 5
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,4,5))
expect_setequal(keep_vals_interior(3, n_models)[["keep"]] , c(1,5))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 1)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 3)
})
test_that("Test keep_vals_interior: even number of models",{
n_models <- 6
# check keep
expect_setequal(keep_vals_interior(2, n_models)[["keep"]] , c(1,2,5,6))
expect_setequal(keep_vals_interior(4, n_models)[["keep"]] , c(1,6))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 2)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 4)
})
test_that("Test keep_vals_interior: even number of models",{
n_models <- 6
# check keep
expect_setequal(keep_vals_interior(2, n_models)[["keep"]] , c(1,2,5,6))
expect_setequal(keep_vals_interior(4, n_models)[["keep"]] , c(1,6))
# check n_trim
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 2)
expect_equal(keep_vals_interior(4, n_models)[["n_trim"]] , 4)
})
#### keep_vals_interior() ####
test_that("Test keep_vals_interior: odd number of models",{
n_models <- 5
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,4,5))
expect_setequal(keep_vals_interior(3, n_models)[["keep"]] , c(1,5))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 1)
expect_equal(keep_vals_interior(2, n_models)[["n_trim"]] , 3)
})
#### keep_vals_interior() ####
test_that("Test keep_vals_interior: odd number of models",{
n_models <- 5
# check keep
expect_setequal(keep_vals_interior(1, n_models)[["keep"]] , c(1,2,4,5))
expect_setequal(keep_vals_interior(3, n_models)[["keep"]] , c(1,5))
# check n_trim
expect_equal(keep_vals_interior(1, n_models)[["n_trim"]] , 1)
expect_equal(keep_vals_interior(3, n_models)[["n_trim"]] , 3)
})
rm(n_models)
rm(keep_vals_interior)
#### check_update_ntrim_even() ####
test_that("Test check_update_ntrim_even()"){
expect_equal(check_update_ntrim_even(2, 2))
expect_equal(check_update_ntrim_even(3,4))
expect_warning(check_update_ntrim_even(3,4))
}
source('~/Documents/GitHub/CombineDistributions/tests/testthat/test_determineTrimVals.R', echo=TRUE)
check_update_ntrim_even <- function(n_trim){
if(n_trim %% 2 == 1){
warning("Cannot trim an odd number of ids with external trimming.
Rounding n_trim up.")
n_trim <- n_trim + 1
}
return(n_trim)
}
expect_equal(check_update_ntrim_even(2, 2))
#### check_update_ntrim_even() ####
test_that("Test check_update_ntrim_even()"){
expect_equal(check_update_ntrim_even(2), 2)
expect_equal(check_update_ntrim_even(3),4)
expect_warning(check_update_ntrim_even(3),4)
}
check_update_ntrim_even(2)
expect_equal(check_update_ntrim_even(2), 2)
check_update_ntrim_even(3)
expect_equal(check_update_ntrim_even(3),4)
#### check_update_ntrim_even() ####
test_that("Test check_update_ntrim_even()"){
expect_equal(check_update_ntrim_even(2), 2)
expect_equal(check_update_ntrim_even(3),3)
expect_warning(check_update_ntrim_even(3),4)
}
expect_equal(check_update_ntrim_even(3),3)
#### check_update_ntrim_even() ####
test_that("Test check_update_ntrim_even()"){
expect_equal(check_update_ntrim_even(2), 2)
expect_equal(check_update_ntrim_even(3), 4)
expect_warning(check_update_ntrim_even(3),4)
}
#### check_update_ntrim_even() ####
test_that("Test check_update_ntrim_even()"){
expect_equal(check_update_ntrim_even(2), 2)
expect_equal(check_update_ntrim_even(3), 4)
expect_warning(check_update_ntrim_even(3))
}
#### check_update_ntrim_even() ####
test_that("Test check_update_ntrim_even()",{
expect_equal(check_update_ntrim_even(2), 2)
expect_equal(check_update_ntrim_even(3), 4)
expect_warning(check_update_ntrim_even(3))
})
check_ntrim_vs_nid(0,4)
check_ntrim_vs_nid(1,4)
check_ntrim_vs_nid <- function(n_trim, n_ids){
if(n_trim >= n_ids){
stop("Trying to trim more values than available (interior).")
}
if(n_trim <= 0){
stop("Number to trim <= 0.")
}
}
check_ntrim_vs_nid(1,4)
check_ntrim_vs_nid(0,4)
#### check_ntrim_vs_nid() ####
test_that("Test check_ntrim_vs_nid()",{
# stop
expect_error(check_ntrim_vs_nid(0,4))
expect_error(check_ntrim_vs_nid(-1,4))
expect_error(check_ntrim_vs_nid(5,4))
})
rm(check_)
rm(check_ntrim_vs_nid())
rm(check_ntrim_vs_nid)
rm(check_update_ntrim_even)
use_readme_md()
library(usethis)
use_readme_md()
setwd("~/Downloads")
library(readr)
read_csv("curated_repos_metadata_21_05_09.csv")
d <- read_csv("curated_repos_metadata_21_05_09.csv")
head(d)
colnames(d)
unique(d$has_tests)
ggplot(data = d, aes(x = n_lines_tot, y = forks), color = 'red', size = 1)+
geom_point(data = d %>% filter(has_tests == "TRUE"))
library(readr)
library(ggplot2)
ggplot(data = d, aes(x = n_lines_tot, y = forks), color = 'red', size = 1)+
geom_point(data = d %>% filter(has_tests == "TRUE"))
library(tidyverse)
ggplot(data = d, aes(x = n_lines_tot, y = forks), color = 'red', size = 1)+
geom_point(data = d %>% filter(has_tests ==x "TRUE"))
ggplot(data = d, aes(x = n_lines_tot, y = forks), color = 'red', size = 1)+
geom_point(data = d %>% filter(has_tests == "TRUE"))
ggplot(data = d, aes(x = n_lines_tot, y = forks))+
geom_point(data = d %>% filter(has_tests == "TRUE"), color = 'red', size = 4)+
geom_point(data = d %>% filter(has_readme == "TRUE"), color = 'green', size = 3)+
theme_bw()
ggplot(data = d, aes(x = n_lines_tot, y = forks))+
geom_point(data = d %>% filter(has_tests == "TRUE"), color = 'red', size = 4)+
geom_point(data = d %>% filter(has_readme == "TRUE"), color = 'green', size = 3)+
scale_x_log10()+
scale_y_log10()+
theme_bw()
ggplot(data = d, aes(x = n_lines_tot, y = forks))+
geom_point(data = d %>% filter(has_tests == "TRUE"), color = 'red', size = 4)+
geom_point(data = d %>% filter(has_readme == "TRUE"), color = 'green', size = 3)+
geom_point(data = d %>% filter(has_license == "TRUE"), color = 'blue', size = 2)+
scale_x_log10()+
scale_y_log10()+
theme_bw()
ggplot(data = d, aes(x = median_commits_per_contributor, y = forks))+
geom_point(data = d %>% filter(has_tests == "TRUE"), color = 'red', size = 4)+
geom_point(data = d %>% filter(has_readme == "TRUE"), color = 'green', size = 3)+
geom_point(data = d %>% filter(has_license == "TRUE"), color = 'blue', size = 2)+
scale_x_log10()+
scale_y_log10()+
theme_bw()
d$concat <-paste(d$has_tests, d$has_readme, d$has_license, sep = "_")
table(d$concat)
d %>% group_by(concat) %>% summarize(count(concat))
d %>% group_by(concat) %>% summarize(c = count(concat))
d %>% group_by(concat) %>% summarize(c = table(concat))
ggplot(data = d %>% group_by(concat) %>% summarize(c = table(concat))) +
geom_bar(aes(x = concat, y = ))
table(d$concat)
tst = table(d$concat)
tst[1]
tst[,1]
ggplot(data = d %>% group_by(concat) %>% summarize(c = length(concat))) +
geom_bar(aes(x = concat, y = ))
d %>% group_by(concat) %>% summarize(c = length(concat))
ggplot(data = d %>% group_by(concat) %>% summarize(c = length(concat))) +
geom_bar(aes(x = concat, y = c))
ggplot(data = d %>% group_by(concat) %>% summarize(c = length(concat))) +
geom_bar(aes(x = concat, y = c), stat = "identity")
ggplot(data = d, aes(x = has_tests, y = has_license))+
geom_point(aes(size = forks), position = position_jitter())
ggplot(data = d %>% group_by(concat, has_tests, has_liscense) %>% summarize(c = length(concat)),
aes(x = has_tests, y = has_license))+
geom_point(aes(size = c), position = position_jitter())
ggplot(data = d %>% group_by(concat, has_tests, has_license) %>% summarize(c = length(concat)),
aes(x = has_tests, y = has_license))+
geom_point(aes(size = c), position = position_jitter())
ggplot(data = d %>% group_by(concat, has_tests, has_license) %>% summarize(c = length(concat)),
aes(x = has_tests, y = has_license, color = has_readme))+
geom_point(aes(size = c), alpha = 0.5)
ggplot(data = d %>% group_by(concat, has_tests, has_license, has_readme) %>% summarize(c = length(concat)),
aes(x = has_tests, y = has_license, color = has_readme))+
geom_point(aes(size = c), alpha = 0.5)
ggplot(data = d %>% group_by(concat, has_tests, has_license, has_readme) %>% summarize(c = length(concat)),
aes(x = has_tests, y = has_license, color = has_readme))+
geom_point(aes(size = c), alpha = 0.5)+
theme_bw()
length(d$has_readme == TRUE)
length(which(d$has_readme == TRUE))
# pct with readme
length(which(d$has_readme == TRUE))/nrow(d)
length(which(d$has_tests == TRUE))/nrow(d)
# pct with readme
length(which(d$has_readme == TRUE))/nrow(d)
length(which(d$has_tests == TRUE))/nrow(d)
length(which(d$has_license == TRUE))/nrow(d)
ggplot(data = d %>%
group_by(has_tests, has_license) %>%
mutate(concat = paste(has_tests, has_license)) %>%
summarize(c = length(concat)),
aes(x = has_tests, y = has_license))+
geom_point(aes(size = c), alpha = 0.5)+
theme_bw()
colnames(d)
